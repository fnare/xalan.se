package se.xalan.utils;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.LinkedList;

public class StringUtils {

    /**
     * Format the time in milliseconds and create a string in seconds. 456 gets
     * converted to "0.456"
     *
     * @param millis The time in milliseconds
     * @return the formatted string
     */
    public static String printSeconds(long millis) {
        String sign = "";
        String pad;

        if (millis < 0) {
            sign = "-";
            millis = -millis;
        }

        if (millis == 0) {
            return "0";
        } else if (millis <= 9) {
            pad = "000";
        } else if (millis <= 99) {
            pad = "00";
        } else if (millis <= 999) {
            pad = "0";
        } else {
            pad = "";
        }
        String res = pad + millis;
        return sign + res.substring(0, res.length() - 3) + "." + res.substring(res.length() - 3, res.length());
    }

    /**
     * Return the stacktrace generated by the supplied Throwable as a string.
     *
     * @param e The Throwable to generate a stacktrace from
     * @param lineBreaksToHtml If this parameter is true, linefeeds in the
     * stacktrace will be converted to <br>:s
     * @return The stacktrace in HTML- or text-format
     *
     *
     */
    public static String getStackTrace(Throwable e, boolean lineBreaksToHtml) {
        StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        if (lineBreaksToHtml) {
            return lineFeedsToHTML(sw.toString());
        } else {
            return sw.toString();
        }
    }

    /**
     * Add <br>:s at each linefeed. (So that the String may be viewed in HTML
     *
     * @param replace The string where <br>:s should be added
     * @return The resulting string
     */
    private static String lineFeedsToHTML(String replace) {
        if (replace == null) {
            return null;
        }

        char chars[] = new char[replace.length()];
        replace.getChars(0, replace.length(), chars, 0);

        StringBuffer sb = new StringBuffer(chars.length);

        char c;

        for (int i = 0; i < chars.length; i++) {
            c = chars[i];
            if (c == '\n') {
                sb.append("<br>\n");
            } else {
                sb.append(c);
            }
        }

        return sb.toString();
    }

    /**
     * Replaces all occurrences in a string with a new string value. 
     * The original string will be returned if there are no occurrences.
     *
     * @param source a <code>String</code> original.
     * @param toReplace a <code>String</code> value. What to search for and replace
     * @param replacement a <code>String</code> value. What to replace with.
     * @return a <code>String</code> value
     */
    public String findReplace(String source, String toReplace, String replacement) {
        if (source.indexOf(toReplace) > -1) {
            StringBuilder sb = new StringBuilder();
            int ix = -1;
            while ((ix = source.indexOf(toReplace)) >= 0) {
                sb.append(source.substring(0, ix)).append(replacement);
                source = source.substring(ix + toReplace.length());
            }
            if (source.length() >= 1) {
                sb.append(source);
            }
            return sb.toString();
        } else {
            return source;
        }
    }

    /**
     * This method replaces null values with the empty string
     *
     * @param str the string to be checked
     * @return the string, where null values is replaced by ""
     */
    public static String nullToString(String s) {
        return (s == null) ? "" : s;
    }

    public static String stringToNull(String s) {
        return isEmpty(s) ? null : s;
    }

    public static String stringToNullTrim(String s) {
        return isEmpty(s) ? null : s.trim();
    }

    public static boolean isEmpty(String s) {
        return (s == null || s.trim().equals(""));
    }

    public static boolean isNotEmpty(String s) {
        return (!isEmpty(s));
    }

    /**
     * Method isDigits takes String - returns true if the string is "0" - "9"
     *
     * @param aString
     * @return boolean
     */
    public static boolean isDigits(String aString) {
        boolean stillOK = true;

        for (int i = 0; stillOK && i < aString.length(); i++) {
            char c = aString.charAt(i);
            stillOK = ((c >= '0' && c <= '9'));
        }
        return stillOK;
    }

    /**
     * isAlfaOnly
     *
     * @param aString string to be checked Returns true if aString contains the
     * characters 'A'-'Z' or 'a'-'z'
     */
    public static boolean isAlfaOnly(String aString) {
        boolean result = false;
        if (aString != null) {
            String testS = aString.toLowerCase();
            boolean stillOK = true;

            for (int i = 0; stillOK && i < testS.length(); i++) {
                char c = testS.charAt(i);
                stillOK = (c >= 'a' && c <= 'z');
            }
            result = stillOK;
        }
        return result;
    }

    /**
     * isAlfaNum
     *
     * @param aString string to be checked Returns true if aString contains the
     * characters 'A'-'Z','a'-'z' or '0'-'9'
     */
    public static boolean isAlfaNum(String aString) {
        if (aString == null) {
            return false;
        } else {
            String testS = aString.toLowerCase();
            boolean stillOK = true;

            for (int i = 0; stillOK && i < testS.length(); i++) {
                char c = testS.charAt(i);
                stillOK = ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'));
            }

            return stillOK;
        }
    }

    /**
     * isAlfaNum2
     *
     * @param aString string to be checked Returns true if aString contains the
     * characters 'A'-'Z','a'-'z', '0'-'9' or '_'
     */
    public static boolean isAlfaNum2(String aString) {
        if (aString == null) {
            return false;
        } else {
            String testS = aString.toLowerCase();
            boolean stillOK = true;

            for (int i = 0; stillOK && i < testS.length(); i++) {
                char c = testS.charAt(i);
                stillOK = ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_');
            }

            return stillOK;
        }
    }

    public static String objectToString(Object o) {
        if (o != null) {
            return (String) o;
        } else {
            return "";
        }
    }

    /**
     * Escape special characters in the string, so that the result can be used
     * in an SQL string (enclosed by '')
     *
     * @param textToEscape The string to escape
     * @return The resulting string
     */
    public static String sqlEscape(String textToEscape) {
        // TODO:: check for more characters?
        if (textToEscape == null) {
            return null;
        }
        if (textToEscape.indexOf('\'') != -1) {
            StringBuffer tmp = new StringBuffer(textToEscape);
            int insertPoint = textToEscape.indexOf('\'');
            while (insertPoint != -1) {
                tmp.insert(insertPoint, '\'');
                textToEscape = tmp.toString();
                insertPoint = textToEscape.indexOf('\'', insertPoint + 2);
            }
            return tmp.toString();
        } else {
            return textToEscape;
        }
    }

    /**
     * Splits the given string on the given token. Follows the semantics of the
     * Java 1.4 {@link String#split(String,int)} method, but does not treat the
     * given token as a regular expression. The method is probably deprecated if
     * Java 1.4 is used...
     *
     * @param str a <code>String</code> to be split
     * @param token a <code>String</code> value used as delimiter
     * @param max an <code>int</code>. Number of "splits" to be made. Unlimited
     * if 0.
     * @return a <code>String[]</code> containing the splitted values
     */
    public static String[] split(String str, String token, int max) {
        if (str == null || str.length() == 0) {
            return new String[0];
        }
        if (token == null || token.length() == 0) {
            throw new IllegalArgumentException("token: [" + token + "]");
        }

        // split on token
        LinkedList ret = new LinkedList();
        int start = 0;
        for (int split = 0; split != -1;) {
            split = str.indexOf(token, start);
            if (split == -1 && start >= str.length()) {
                ret.add("");
            } else if (split == -1) {
                ret.add(str.substring(start));
            } else {
                ret.add(str.substring(start, split));
                start = split + token.length();
            }
        }

        // now take max into account; this isn't the most efficient way
        // of doing things since we split the maximum number of times
        // regardless of the given parameters, but it makes things easy
        if (max == 0) {
            // discard any trailing empty splits
            while (ret.getLast().equals("")) {
                ret.removeLast();
            }
        } else if (max > 0 && ret.size() > max) {
            // move all splits over max into the last split
            StringBuilder buf = new StringBuilder(ret.removeLast().toString());
            while (ret.size() >= max) {
                buf.insert(0, token);
                buf.insert(0, ret.removeLast());
            }
            ret.add(buf.toString());
        }

        return (String[]) ret.toArray(new String[ret.size()]);
    }

    /**
     * This method removes any leading zeros from the beginning of a string
     *
     * @param str the string to be trimmed
     * @return the string, where leading zeros has been removed
     */
    public static String trimLeadingZeros(String str) {
        int pos = 0;
        if (str == null) {
            return null;
        }
        for (int i = 0; i < str.length(); i++) {
            if (pos == 0 && str.charAt(i) != '0') {
                pos = i;
            }
        }
        return str.substring(pos);
    }

    /**
     * Function to format text depending on requirements
     *
     * @param String Arbitrary string to be formatted        
     * @param long Desired length of returned string
     * @param char Characters that should be used to fill
     * @param String Adjusting 'L' (left), 'R' (right)
     * @return String The formatted string or null if there is something wrong
     */
    public static String stringFormatter(String inStr, int len, String filler, String align) {
        String outStr = "";
        if (align == null) {
            return null;
        }
        if (inStr == null) {
            if (filler != null && filler.length() > 0) {
                // Skapa en str�ng med angivet antal tecken
                for (int i = 0; i < len; i++) {
                    outStr = outStr + filler;
                }
                return outStr;
            } else {
                return null;
            }
        } else {
            if (align.toUpperCase().equals("L")) {
                if (len > inStr.length()) {
                    for (int i = 0; i < len - inStr.length(); i++) {
                        outStr = outStr + filler;
                    }
                    return inStr + outStr;
                } else {
                    return inStr.substring(0, len);
                }
            } else if (align.toUpperCase().equals("R")) {
                if (len > inStr.length()) {
                    for (int i = 0; i < len - inStr.length(); i++) {
                        outStr = outStr + filler;
                    }
                    return outStr + inStr;
                } else {
                    return inStr.substring(inStr.length() - len);
                }
            } else {
                return null;
            }
        }

    }

    /**
     * toHexString Takes a sting and converts it to a Hex coded string (twice as
     * long)
     *
     * @param str String to convert to Hex string.
     * @return a hex coded string.
     */
    public static String toHexString(String str) {
        String hexString = "";
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            int lo = (c % 16);
            int hi = (c / 16);
            hexString = hexString + Character.forDigit(hi, 16) + Character.forDigit(lo, 16);
        }
        return hexString.toUpperCase();
    }

    /**
     * fromHexString Takes a Hex coded string and converts it back to the
     * original string (half as long)
     *
     * @param str Hex String to decode
     * @return decoded string.
     */
    public static String fromHexString(String hex) {
        int l = hex.length();
        String bin = "";
        for (int i = 0; i < l - 1; i += 2) {
            int x = d(hex.charAt(i)) * 16 + d(hex.charAt(i + 1));
            byte[] b = {(byte) x};
            bin = bin + new String(b);
        }
        return bin;
    }

    private static int d(char c) {
        if (c < '0') {
            return 0;
        }
        if (c <= '9') {
            return c - '0';
        }
        if (c < 'A') {
            return 0;
        }
        if (c <= 'F') {
            return 10 + c - 'A';
        }
        if (c < 'a') {
            return 0;
        }
        if (c <= 'f') {
            return 10 + c - 'a';
        }
        return 0;
    }
}
